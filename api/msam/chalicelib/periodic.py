# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
"""
This file contains helper functions for updating the cache.
"""

import os
import time
import xml.etree.ElementTree as ET
import json

import boto3
from botocore.exceptions import ClientError
from botocore.config import Config
from boto3.dynamodb.conditions import Key

import chalicelib.settings as msam_settings
import chalicelib.cloudwatch as cloudwatch_data
import chalicelib.connections as connection_cache
import chalicelib.nodes as node_cache
from chalicelib.cache import regions
import chalicelib.tags as tags

# table names generated by CloudFormation
ALARMS_TABLE_NAME = os.environ["ALARMS_TABLE_NAME"]
CONTENT_TABLE_NAME = os.environ["CONTENT_TABLE_NAME"]

# user-agent config
STAMP = os.environ["BUILD_STAMP"]
MSAM_BOTO3_CONFIG = Config(user_agent="aws-media-services-applications-mapper/{stamp}/periodic.py".format(stamp=STAMP))

SSM_LOG_GROUP_NAME = "MSAM/SSMRunCommand"

def update_alarms():
    """
    Entry point for the CloudWatch scheduled task to discover and cache services.
    """
    try:
        print("update alarms")
        resource_cache = {}
        updated = int(time.time())
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb', config=MSAM_BOTO3_CONFIG)
        ddb_table = ddb_resource.Table(ddb_table_name)
        for alarm in cloudwatch_data.all_subscribed_alarms():
            region = alarm["Region"]
            name = alarm["AlarmName"]
            if region in resource_cache:
                cloudwatch = resource_cache[region]
            else:
                cloudwatch = boto3.resource('cloudwatch', region_name=region, config=MSAM_BOTO3_CONFIG)
                resource_cache[region] = cloudwatch
            alarm = cloudwatch.Alarm(name)
            region_alarm_name = "{}:{}".format(region, name)
            # look up the resources with this region alarm name
            subscribers = cloudwatch_data.subscribers_to_alarm(name, region)
            for resource_arn in subscribers:
                item = {
                    "RegionAlarmName": region_alarm_name,
                    "ResourceArn": resource_arn,
                    "StateValue": alarm.state_value,
                    "Namespace": alarm.namespace,
                    "StateUpdated": int(alarm.state_updated_timestamp.timestamp()),
                    "Updated": updated
                }
                ddb_table.put_item(Item=item)
    except ClientError as error:
        print(error)
    return True


def update_connections():
    """
    Entry point for the CloudWatch scheduled task to discover and cache services.
    """
    try:
        connection_cache.update_connection_ddb_items()
    except ClientError as error:
        print(error)
    return True


def update_nodes():
    """
    Entry point for the CloudWatch scheduled task to discover and cache services.
    """
    try:
        never_regions_key = "never-cache-regions"
        never_regions = msam_settings.get_setting(never_regions_key)
        if never_regions is None:
            never_regions = []
        settings_key = "cache-next-region"
        # make a region name list
        region_name_list = []
        for region in regions():
            region_name = region["RegionName"]
            # exclude regions listed in never-cache setting
            if region_name not in never_regions:
                region_name_list.append(region_name)
            else:
                print("{} in {} setting".format(region_name, never_regions_key))
        # sort it
        region_name_list.sort()
        # get the next region to process
        next_region = msam_settings.get_setting(settings_key)
        # start at the beginning if no previous setting
        if next_region is None:
            next_region = region_name_list[0]
        # otherwise it's saved for us
        region_name = next_region
        # store the region for the next schedule
        try:
            # process global after the end of the region list
            if region_name_list.index(next_region) + 1 >= len(region_name_list):
                next_region = "global"
            else:
                next_region = region_name_list[region_name_list.index(next_region) + 1]
        except (IndexError, ValueError):
            # start over if we don't recognize the region, ex. global
            next_region = region_name_list[0]
        # store it
        msam_settings.put_setting(settings_key, next_region)
        # update the region
        print("updating region {}".format(region_name))
        if region_name == "global":
            node_cache.update_global_ddb_items()
        else:
            node_cache.update_regional_ddb_items(region_name)
    except ClientError as error:
        print(error)
    return region_name


def update_from_tags():
    """
    Updates MSAM diagrams and tiles from tags on cloud resources. Check for MSAM-Diagram and MSAM-Tile tags.
    """
    tags.update_diagrams()
    tags.update_tiles()

def ssm_run_command():
    """
    Runs all applicable SSM document commands on a given managed instance.
    """
    try:
        table_name = CONTENT_TABLE_NAME
        ssm_client = boto3.client('ssm', config=MSAM_BOTO3_CONFIG)
        db_resource = boto3.resource('dynamodb', config=MSAM_BOTO3_CONFIG)
        db_table = db_resource.Table(table_name)
        instance_ids = {}
        items = []
        # get all the managed instances from the DB with tag MSAM-NodeType 
        response = db_table.query(
            IndexName="ServiceRegionIndex", 
            KeyConditionExpression=Key("service").eq("ssm-managed-instance"), 
            FilterExpression="contains(#data, :tagname)", 
            ExpressionAttributeNames={"#data": "data"}, 
            ExpressionAttributeValues={":tagname": "MSAM-NodeType"}
            )
        if "Items" in response:
            items = response["Items"]
        while "LastEvaluatedKey" in response:
            response = db_table.query(
            IndexName="ServiceRegionIndex", 
            KeyConditionExpression=Key("service").eq("ssm-managed-instance"), 
            FilterExpression="contains(#data, :tagname)", 
            ExpressionAttributeNames={"#data": "data"}, 
            ExpressionAttributeValues={":tagname": "MSAM-NodeType"},
            ExclusiveStartKey=response['LastEvaluatedKey']
            )            
            if "Items" in response:
                items.append(response["Items"])

        for item in items:
            data = json.loads(item['data'])
            if "MSAM-NodeType" in data["Tags"]:
                instance_ids[data['Id']] = data['Tags']['MSAM-NodeType']

        # get all the SSM documents applicable to MSAM, filtering by MSAM-NodeType tag
        # When we support more than just ElementalLive, add to the list of values for MSAM-NodeType during filtering
        document_list = ssm_client.list_documents(
            Filters=[
                {
                    'Key': 'tag:MSAM-NodeType',
                    'Values': [
                        'ElementalLive',
                    ]
                },
                {
                    'Key': 'Owner',
                    'Values': [
                        'Self'
                    ]
                }
            ]
        )
        document_ids = document_list['DocumentIdentifiers']
        while "NextToken" in document_list:
            document_list = ssm_client.list_documents(
                Filters=[
                    {
                        'Key': 'tag:MSAM-NodeType',
                        'Values': [
                            'ElementalLive',
                        ]
                    },
                    {
                        'Key': 'Owner',
                        'Values': [
                            'Self'
                        ]
                    }
                ],
                NextToken=document_list["NextToken"]
            )
            document_ids.append(document_list['DocumentIdentifiers'])

        document_names = {}
        for document in document_ids:
            if "Tags" in document:
                for tag in document["Tags"]:
                    if tag['Key'] == "MSAM-NodeType":
                        document_names[document["Name"]] = tag['Value']
        
        # loop over all instances and run applicable commands based on node type
        for id, id_type in instance_ids.items():
            for name, doc_type in document_names.items():
                if id_type in doc_type: 
                    # maybe eventually doc type could be comma-delimited string if doc applies to more than one type?
                    print("running command: %s on %s " % (name, id))
                    response = ssm_client.send_command(
                        InstanceIds=[
                            id,
                        ],
                        DocumentName=name,
                        TimeoutSeconds=600,
                        Parameters={
                        },
                        MaxConcurrency='50',
                        MaxErrors='0',
                        CloudWatchOutputConfig={
                            'CloudWatchLogGroupName': SSM_LOG_GROUP_NAME,
                            'CloudWatchOutputEnabled': True
                        }
                    )
                    print(response)
    except ClientError as error:
        print(error)


def process_ssm_run_command(event):
    """
    Processes the results from running an SSM command on a managed instance.
    """
    event_dict = event.to_dict()
    instance_id = event_dict['detail']['instance-id']
    command_name = event_dict['detail']['document-name']
    command_status = event_dict['detail']['status']
    cw_client = boto3.client('cloudwatch', config=MSAM_BOTO3_CONFIG)
    log_client = boto3.client('logs', config=MSAM_BOTO3_CONFIG)
    dimension_name = "Instance ID"
    metric_name = command_name
    status = 0

    try:
        if command_status == "Success":            
            # test to make sure stream names are always of this format, esp if you create your own SSM document
            log_stream_name = event_dict['detail']['command-id'] + "/" + instance_id + "/aws-runShellScript/stdout"
            
            response = log_client.get_log_events(
                logGroupName=SSM_LOG_GROUP_NAME,
                logStreamName=log_stream_name,
            )
            
            # process document name (command)
            if "MSAMElementalLiveStatus" in command_name:
                metric_name = "MSAMElementalLiveStatus"
                for event in response['events']:
                    if "running" in event['message']:
                        status = 1
            elif "MSAMSsmSystemStatus" in command_name:
                metric_name = "MSAMSsmSystemStatus"
                status = 1
            elif "MSAMElementalLiveActiveAlerts" in command_name:
                metric_name = "MSAMElementalLiveActiveAlerts"
                root = ET.fromstring(response['events'][0]['message'])
                status = len(list(root))
                if status == 1 and root[0].tag == "empty":
                    status = 0
            else: 
                if "MSAMElementalLiveCompletedEvents" in command_name:
                    metric_name = "MSAMElementalLiveCompletedEvents"
                elif "MSAMElementalLiveErroredEvents" in command_name:
                    metric_name = "MSAMElementalLiveErroredEvents"
                elif "MSAMElementalLiveRunningEvents" in command_name:
                    metric_name = "MSAMElementalLiveRunningEvents"
                root = ET.fromstring(response['events'][0]['message'])
                status = len(root.findall("./live_event"))
        else:
            # log if command has timed out or failed
            print("SSM Command Status: Command %s sent to instance %s has %s" % (command_name, instance_id, command_status))
            # create a metric for it
            status = 1
            metric_name = "MSAMSsmCommand"+command_status

        cw_client.put_metric_data(
            Namespace = SSM_LOG_GROUP_NAME,
            MetricData = [
                {
                    'MetricName': metric_name,
                    'Dimensions': [
                        {
                            'Name' : dimension_name,
                            'Value' : instance_id
                        },
                    ],
                    "Value": status,
                    "Unit": "Count"
                }
            ]
        )
    except ClientError as error:
        print(error)

