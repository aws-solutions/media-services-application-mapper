# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
"""
This file contains helper functions for building the node cache.
"""

import json
import os

import boto3
from botocore.config import Config
from botocore.exceptions import ClientError
import stringcase

import chalicelib.channels as channels
import chalicelib.settings as settings
import chalicelib.layout as layout

# table names generated by CloudFormation
CONTENT_TABLE_NAME = os.environ["CONTENT_TABLE_NAME"]

# used to handle throttling
BOTO3_RETRY_CONFIG = Config(retries={'max_attempts': 15})


def update_diagrams():
    """
    scan for data with tags with MSAM-Diagram name and include in those named diagrams
    """
    try:
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        # expensive textual scan
        response = ddb_table.scan(FilterExpression="contains(#data, :tagname)", ExpressionAttributeNames={"#data": "data"}, ExpressionAttributeValues={":tagname": "MSAM-Diagram"})
        items = response["Items"]
        # check for paging
        while "LastEvaluatedKey" in response:
            # scan again with start key
            response = ddb_table.scan(
                FilterExpression="contains(#data, :tagname)",
                ExpressionAttributeNames={"#data": "data"},
                ExpressionAttributeValues={":tagname": "MSAM-Diagram"},
                ExclusiveStartKey=response['LastEvaluatedKey'])
            items = items + response["Items"]
        # filter down the results
        for record in items:
            cloud_resource = json.loads(record["data"])
            if "Tags" in cloud_resource:
                if "MSAM-Diagram" in cloud_resource["Tags"]:
                    arn = record["arn"]
                    diagram_name = cloud_resource["Tags"]["MSAM-Diagram"]
                    print("arn {} needed on diagram {}".format(arn, diagram_name))
                    diagrams = settings.get_setting("diagrams")
                    if not diagrams:
                        diagrams = []
                    found_diagram = False
                    view_id = None
                    for diagram in diagrams:
                        if diagram["name"] == diagram_name:
                            view_id = diagram["view_id"]
                            found_diagram = True
                            print("found diagram id {}".format(view_id))
                    if not found_diagram:
                        view_id = stringcase.snakecase(diagram_name)
                        print("new diagram id {}".format(view_id))
                        diagrams.append({"name": diagram_name, "view_id": view_id})
                        settings.put_setting("diagrams", diagrams)
                        print("created diagram id {}".format(view_id))
                    # check if this node is already on the diagram layout
                    if not layout.has_node(view_id, arn):
                        print("adding node {} to diagram id {}".format(arn, view_id))
                        # add the node arn to the layout
                        layout_items = [{"view": view_id, "id": arn, "x": 0, "y": 0}]
                        layout.set_node_layout(layout_items)
                    else:
                        print("node {} already on diagram id {}".format(arn, view_id))
    except ClientError as error:
        print(error)


def update_tiles():
    """
    scan for data with tags with MSAM-Tile name and include in those named tiles
    """
    try:
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        # very broad textual scan
        response = ddb_table.scan(FilterExpression="contains(#data, :tagname)", ExpressionAttributeNames={"#data": "data"}, ExpressionAttributeValues={":tagname": "MSAM-Tile"})
        items = response["Items"]
        # check for paging
        while "LastEvaluatedKey" in response:
            # scan again with start key
            response = ddb_table.scan(
                FilterExpression="contains(#data, :tagname)",
                ExpressionAttributeNames={"#data": "data"},
                ExpressionAttributeValues={":tagname": "MSAM-Tile"},
                ExclusiveStartKey=response['LastEvaluatedKey'])
            items = items + response["Items"]
        # filter down the results
        for record in items:
            cloud_resource = json.loads(record["data"])
            if "Tags" in cloud_resource:
                if "MSAM-Tile" in cloud_resource["Tags"]:
                    arn = record["arn"]
                    tile_name = cloud_resource["Tags"]["MSAM-Tile"]
                    print("arn {} needed on tile {}".format(arn, tile_name))
                    nodes = channels.get_channel_nodes(tile_name)
                    ids = [item["id"] for item in nodes]
                    print("existing tile contents: {}".format(json.dumps(ids)))
                    if arn not in ids:
                        print("adding {} to tile {}".format(arn, tile_name))
                        ids.append(arn)
                        print("updated tile contents: {}".format(json.dumps(ids)))
                        channels.set_channel_nodes(tile_name, ids)
                    else:
                        print("already present on tile")
    except ClientError as error:
        print(error)
